<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>AnimationStage=0
//starting position
x=-view_wport[0]
y=0
backtgtx=0
ControlParent=0
Draws=2
//selectable decks
DeckBaseScale=0.4
DeckSprite[0]=spr_cardsback
DeckImage[0]=0
DeckScale[0]=DeckBaseScale
DeckHover[0]=false

DeckSprite[1]=spr_cardsback
DeckImage[1]=1
DeckScale[1]=DeckBaseScale
DeckHover[1]=false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ControlParent.GUIObjectOrder[| 0]!=id{exit;}
switch(AnimationStage){
    case 0://bring black background
        if x &gt; (-view_wport[0]/4*3){
            AnimationStage=1
        }
    break;
    case 1://how to exit
        if keyboard_check_pressed(vk_escape){
            AnimationStage=3
            ds_list_delete(ControlParent.GUIObjectOrder,0)
        }
        if Draws&lt;1 || ds_list_empty(ControlParent.DeckList){// || ds_list_empty(ControlParent."Spells") [Not yet implemented]
            AnimationStage=3
            ds_list_delete(ControlParent.GUIObjectOrder,0)
        }
        
    break;
    case 3://pack up all
        backtgtx=-view_wport[0]
        if abs(x-backtgtx)&lt;0.1{
            AnimationStage=4
        }
    break;
    case 4:
        instance_destroy()
    break;
}

//Lerping the background
x=lerp(x,backtgtx,0.2)


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if ControlParent.GUIObjectOrder[| 0]!=id{exit;}
draw_set_alpha(0.2)
draw_set_color(c_black)
//draw black background
draw_rectangle(x,y,x+view_wport[0],y+view_hport[0],false)
//draw title
draw_set_halign(fa_center)
draw_text(x+view_wport[0]/2,y+10,"Select Deck to Draw")
draw_text(x+view_wport[0]/2,y+30,"Press 'esc' to cancel")
draw_set_valign(fa_left)

//Selectable decks
var msx=device_mouse_x_to_gui(0)
var msy=device_mouse_y_to_gui(0)
for(var i=0;i&lt;array_length_1d(DeckSprite);i++){
    var canDraw=true
    if Draws&lt;1{canDraw=false}
    if i=0 &amp;&amp; ds_list_empty(ControlParent.DeckList){canDraw=false}//if unit deck is empty
    if i=1 {canDraw=true}//if spell deck is empty [Not implemented]
    
    //draw sprite
    var _clr=c_white
    if !canDraw{_clr=c_gray}
    var _x=view_wport[0]/(array_length_1d(DeckSprite)+1)*(i+1)
    var _y=view_hport[0]/2
    draw_sprite_ext(DeckSprite[i],DeckImage[i],_x+x,_y+y,DeckScale[i],DeckScale[i],0,_clr,1)
    
    
    //checking for collision
    if !canDraw{continue;}
    DeckHover[i]=false
    if point_in_rectangle(msx,msy,
        _x+x-sprite_get_width(DeckSprite[i])/2*DeckScale[i],
        _y+y-sprite_get_height(DeckSprite[i])/2*DeckScale[i],
        _x+x+sprite_get_width(DeckSprite[i])/2*DeckScale[i],
        _y+y+sprite_get_height(DeckSprite[i])/2*DeckScale[i],
    ){DeckHover[i]=true}
    //do the selection animatiion
    if DeckHover[i]=true{
        DeckScale[i]=DeckBaseScale+sin(current_time/100)*0.01
        //clicking of card
        if mouse_check_button_pressed(mb_left){
            switch(i){
                case 0://draw unit card
                    CardID=ControlParent.DeckList[| 0]
                    ds_list_delete(ControlParent.DeckList,0)
                    with(global.NetworkObj.socket_to_instanceid[? global.NetworkObj.mysocket]){
                        var _card=GameEvent_draw_specific_card(other.CardID);
                        _card.CardType=0
                        _card.x=_x
                        _card.y=_y
                    }
                break;
                case 1://draw spell card [not yet implemented]
                    CardID=SpellID.Hexeria_BlueElixir//irandom_range(1,SpellID.SpellID_MAX-1)
                    //ds_list_delete(ControlParent.DeckList,0)
                    with(global.NetworkObj.socket_to_instanceid[? global.NetworkObj.mysocket]){
                        var _card=GameEvent_draw_specific_card(other.CardID);
                        _card.CardType=1
                        _card.x=_x
                        _card.y=_y
                    }
                break;
            }
            //reduce number of draws available
            Draws--
        }
    }
}



draw_set_alpha(1)
draw_set_color(c_white)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
