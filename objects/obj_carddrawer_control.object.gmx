<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>AnimationStage=0
//starting position
x=-view_wport[0]
y=0
backtgtx=0
ControlParent=0
Draws=2
//selectable decks
DeckBaseScale=0.4
DeckSprite[0]=spr_cardsback
DeckImage[0]=0
DeckScale[0]=DeckBaseScale
DeckHover[0]=false

DeckSprite[1]=spr_cardsback
DeckImage[1]=1
DeckScale[1]=DeckBaseScale
DeckHover[1]=false
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//appearing animation
if ControlParent.GUIObjectOrder[| 0]=id{
    switch(AnimationStage){
        case 0://bring black background
            if x &gt; (-view_wport[0]/4*3){
                AnimationStage=1
            }
        break;
        case 1://how to exit
            if keyboard_check_pressed(vk_escape){
                AnimationStage=3
                ds_list_delete(ControlParent.GUIObjectOrder,0)
            }
            if ds_list_size(ControlParent.cardList)&gt;=(10+ControlParent.Hero.Stats[? "ExtraHandCards"]){
                Draws=0
            }
        break;
    }
}

//exit animation
switch(AnimationStage){
    case 3://pack up all
        backtgtx=-view_wport[0]
        if abs(x-backtgtx)&lt;0.1{
            AnimationStage=4
        }
    break;
    case 4:
        instance_destroy()
    break;
}

//Lerping the background
if ControlParent.GUIObjectOrder[| 0]=id || AnimationStage&gt;2{
    x=lerp(x,backtgtx,0.2)
}






</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_alpha(0.2)
draw_set_color(c_black)
//draw black background
draw_rectangle(x,y,x+view_wport[0],y+view_hport[0],false)
//draw title
draw_set_halign(fa_center)
draw_text(x+view_wport[0]/2,y+10,"Select Deck to Draw")
draw_text(x+view_wport[0]/2,y+30,"Press 'esc' to cancel")
draw_set_halign(fa_left)

//Selectable decks
var msx=device_mouse_x_to_gui(0)
var msy=device_mouse_y_to_gui(0)
for(var i=0;i&lt;array_length_1d(DeckSprite);i++){
    var canDraw=true
    if i=0 &amp;&amp; ds_list_empty(ControlParent.DeckList){canDraw=false}//if unit deck is empty
    if i=1 &amp;&amp; ds_list_empty(ControlParent.SpellList){canDraw=false}//if spell deck is empty [Not implemented]
    if Draws&lt;1{canDraw=false}
    
    //draw sprite
    var _clr=c_white
    if !canDraw{_clr=c_gray}
    var _x=view_wport[0]/(array_length_1d(DeckSprite)+1)*(i+1)
    var _y=view_hport[0]/2
    draw_sprite_ext(DeckSprite[i],DeckImage[i],_x+x,_y+y,DeckScale[i],DeckScale[i],0,_clr,1)
    
    //checking for collision
    if canDraw &amp;&amp; ControlParent.GUIObjectOrder[| 0]=id{
        DeckHover[i]=false
        if point_in_rectangle(msx,msy,
            _x+x-sprite_get_width(DeckSprite[i])/2*DeckScale[i],
            _y+y-sprite_get_height(DeckSprite[i])/2*DeckScale[i],
            _x+x+sprite_get_width(DeckSprite[i])/2*DeckScale[i],
            _y+y+sprite_get_height(DeckSprite[i])/2*DeckScale[i],
        ){DeckHover[i]=true}
        //do the selection animatiion
        if DeckHover[i]=true{
            DeckScale[i]=DeckBaseScale+sin(current_time/100)*0.01
            //clicking of card
            if mouse_check_button_pressed(mb_left){
                switch(i){
                    case 0://draw unit card
                        CardID=ControlParent.DeckList[| 0]
                        ds_list_delete(ControlParent.DeckList,0)
                        with(global.NetworkObj.socket_to_instanceid[? global.NetworkObj.mysocket]){
                            var _card=GameEvent_draw_specific_card(other.CardID,0);
                            _card.x=_x
                            _card.y=_y
                        }
                    break;
                    case 1://draw spell card [not yet implemented]
                        CardID=ControlParent.SpellList[| 0]
                        ds_list_delete(ControlParent.SpellList,0)
                        with(global.NetworkObj.socket_to_instanceid[? global.NetworkObj.mysocket]){
                            var _card=GameEvent_draw_specific_card(other.CardID,1);
                            _card.x=_x
                            _card.y=_y
                        }
                    break;
                }
                //reduce number of draws available
                Draws--
                if Draws&lt;1{
                    AnimationStage=3
                    ds_list_delete(ControlParent.GUIObjectOrder,0)
                }
            }
        }
    }
}

//exit button
var _x=view_wport[0]-100+x
var _y=50+y
var _w=50
var _h=50
draw_set_color(c_red)
draw_rectangle(_x,_y,_x+_w,_y+_h,false)
if point_in_rectangle(msx, msy, _x, _y, _x+_w, _y+_h,){
    if mouse_check_button_pressed(mb_left){
        AnimationStage=3
        ds_list_delete(ControlParent.GUIObjectOrder,0)
    }
}
draw_line_width(_x,_y,_x+_w,_y+_h,3)
draw_line_width(_x,_y+_h,_x+_w,_y,3)

draw_set_alpha(1)
draw_set_color(c_white)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
